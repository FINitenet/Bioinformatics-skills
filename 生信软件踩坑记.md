<a name="content">目录</a>

[生信软件踩坑记](#title)
- [Fastq-dump](#fastq-dump)





<h1 name="title">生信软件踩坑记</h1>

<a name="fastq-dump"><h2>Fastq-dump [<sup>目录</sup>](#content)</h2></a>

NCBI的fastq-dump软件一直被大家归为目前网上文档做的最差的软件之一

我们一般使用fastq-dump的方式为:

```
$ fastq-dump /path/to/xxx.sra 
```

但是这个默认使用方法得到结果往往很糟，比如说他默认会把双端测序结果保存到一个文件里，但是如果你加上--split-3之后，他会把原来双端拆分成两个文件，但是原来单端并不会保存成两个文件。 还有你用--gzip就能输出gz格式，能够节省空间的同时也不会给后续比对软件造成压力，比对软件都支持，就是时间要多一点。

这些东西在官方文档并没有特别说明，你只有通过不断的踩坑才能学到这些小知识。

- reads拆分

	默认情况下fastq-dump不对reads进行拆分，对于很早之前的单端测序没有出现问题。但是对于双端测序而言，就会把原本的两条reads合并成一个，后续分析必然会出错。
	
	常见的参数有三类:

	> - --split-spot: 将双端测序分为两份，但是都放在同一个文件中
	> - --split-files: 将双端测序分为两份，放在不同的文件，但是对于一方有而一方没有的reads直接丢弃
	> - --split-3 : 将双端测序分为两份，放在不同的文件，但是对于一方有而一方没有的reads会单独放在一个文件夹里

- read ID

默认双端测序数据拆分后得到两个文件中同一个reads的名字是一样的，但是加上`-I | --readids`之后同一个reads的ID就会加上`.1`和`.2`进行区分。举个例子

| 是否有-I参数 | ID 1 | ID 2 |
|:---:|:---|:---|
| 无 | @SRR5829230.1 1 length=36 | @SRR5829230.1 1 length=36 |
| 有 | @SRR5829230.1.1 1 length=36 | @SRR5829230.1.2 1 length=36 |

问题来了，明明已经可以通过ID后面的"1"和"2"来区分ID，加这个参数干嘛。加完之后还会让后续的BWA报错。所以，没事千万别加

- 原始格式

	默认情况下输出的文件的ID都是SRR开头，但其实原始数据名字不是这样子，比如说`@ST-E00600:143:H3LJWALXX:1:1101:5746:1016 2:N:0:CCTCCTGA,@HWI-ST620:248:HB11HADXX:2:1101:1241:2082#0/1`这种。如果你想看到那种格式，而不是SRR，你需要怎么做呢?

	> - `F|--origfmt`: 仅保留数据名字
	> - `--defline-seq <fmt>`: 定义readsID的显示方式
	> - `--defline-qual <fmt>`: 定义质量的显示方式

	<p align="center"><img src=./picture/Use-Biosoft-Fastq-dump-outfmt.png width=600 /></p>



---

参考资料：

(1) [简书：Fastq-dump: 一个神奇的软件](https://www.jianshu.com/p/a8d70b66794c)
